#include <iostream>
#include <fstream>
#include <sstream>
#include <chrono>
#include <regex>
//#include "base64.h"
//#include "git_commit_hash.h"
#include "yaml_parser.h"

using namespace yaml;
#define ELRF(message) do { if (!is_batch_) std::cout << message << std::endl; return false; } while(0)
#define INFO_LOG_PREFIX "base->Log(core::LOG_INFO, std::string(\"", file_info_.info.yml.id, "\") + \" (\" + base->GetSelfName() + \")\" + "
#define ERROR_LOG_PREFIX "base->Log(core::LOG_ERROR, std::string(\"", file_info_.info.yml.id, "\") + \" (\" + base->GetSelfName() + \")\" + "

yaml_parser::yaml_parser(bool is_batch)
{
	is_batch_ = is_batch;
	file_info_ = {};

	type_type_names_["enum"] = "str";

	system_type_names_["unit"] = "str";
	system_type_names_["path"] = "str";
	system_type_names_["string"] = "str";

	cpp_type_names_["double"] = "dbl";
	cpp_type_names_["int"] = "int";
	cpp_type_names_["bool"] = "bool";
	cpp_type_names_["std::string"] = "str";
	cpp_type_names_["float"] = "dbl";
	cpp_type_names_["int8_t"] = "int";
	cpp_type_names_["int16_t"] = "int";
	cpp_type_names_["int32_t"] = "int";
	cpp_type_names_["int64_t"] = "int";
	cpp_type_names_["uint8_t"] = "int";
	cpp_type_names_["uint16_t"] = "int";
	cpp_type_names_["uint32_t"] = "int";
	cpp_type_names_["uint64_t"] = "int";

	xml_type_names_["dbl"] = "double";
	xml_type_names_["int"] = "int";
	xml_type_names_["bool"] = "bool";
	xml_type_names_["str"] = "std::string";
}

bool yaml_parser::parse(const std::string& filename)
{
	YAML::Node config{};
	try
	{
		config = YAML::LoadFile(filename);
	}
	catch(...)
	{
		ELRF("File " << filename << " load failed");
	}

	file_info fi;
	if (!get_file_info(config, file_info_))
		ELRF("File info parse failed");
	return true;
}

bool yaml_parser::get_code(std::list<std::string>& code)
{
	if (!get_file_code(code))
		ELRF("Get file code failed");
	return true;
}

bool yaml_parser::get_wiki(std::list<std::string>& wiki)
{
	if (!get_file_wiki(wiki))
		ELRF("Get file wiki failed");
	return true;
}

bool yaml_parser::get_xml(std::list<std::string>& xml)
{
	if (!get_file_xml(xml))
		ELRF("Get file xml failed");
	return true;
}

bool yaml_parser::get_html(std::list<std::string>& html)
{
	if (!get_file_html(html))
		ELRF("Get file html failed");
	return true;
}

template <typename... Args>
std::string yaml_parser::make_string(Args&&... args)
{
	std::stringstream out;
	using expander = int[];
	(void)expander {
		0, (void(out << std::forward<Args>(args)), 0)...
	};
	return out.str();
}

template<typename T>
bool yaml_parser::try_get_yaml_value(const YAML::Node& node, const std::string& name, T& value)
{
	if (!node[name])
		return false;
	value = node[name].as<T>();
	return true;
}

bool yaml_parser::get_file_code(std::list<std::string>& code)
{
	code.push_back("#pragma once");
	code.push_back("");
	code.push_back("////////////////////////////////////////////////////////////////////////////////");
	code.push_back("// This file was autogenerated with parameters_compiler");
	code.push_back("// Any changes to this file will be overwritten by the next CMake run");
	// code.push_back(make_string("// Git commit hash of parameters_compiler: ", GIT_COMMIT_HASH));
	code.push_back(make_string("// Input file format: ", file_info_.format));
	code.push_back(make_string("// Unit name: ", file_info_.info.get_display_name_cp1251()));
	code.push_back(make_string("// Unit ID: ", file_info_.info.yml.id));
	code.push_back("////////////////////////////////////////////////////////////////////////////////");
	code.push_back("");
	code.push_back("#include <string>");
	code.push_back("#include <vector>");
	code.push_back("#include <set>");
	code.push_back("#include <map>");
	code.push_back("#include \"base_library/base_library.h\"");
	for (const auto& ti : file_info_.types)
	{
		if (ti.category == type_category::user_cpp)
		{
			for (const auto& s : ti.yml.includes)
				code.push_back(make_string("#include \"", s, "\""));
		}
	}
	code.push_back("");
	code.push_back("namespace parameters_compiler");
	code.push_back("{");
	code.push_back(make_string("\t", "static const std::string git_commit_hash = \"@GIT_COMMIT_HASH@\";"));
	code.push_back(make_string("\t", "static const std::string git_status = \"@GIT_STATUS@\";"));
	code.push_back("");

	for (const auto& ti : file_info_.types)
	{
		//if (type.category == type_category::user_yml)
		{
			std::list<std::string> type_code;
			if (!get_type_code(ti, type_code))
				ELRF("Get type code failed");
			for (const auto& s : type_code)
				code.push_back(make_string("\t", s));
		}
		code.push_back("");
	}

	std::list<std::string> main_parameters_code;
	if (!get_main_code(main_parameters_code))
		ELRF("Get main parameters code failed");
	for (const auto& s : main_parameters_code)
		code.push_back(make_string("\t", s));

	code.push_back("}");

	return true;
}

bool yaml_parser::get_file_wiki(std::list<std::string>& wiki)
{
	//wiki.push_back("////////////////////////////////////////////////////////////////////////////////");
	//wiki.push_back("// This file was autogenerated with parameters_compiler");
	//wiki.push_back("// Any changes to this file will be overwritten by the next CMake run");
	//wiki.push_back(make_string("// Git commit hash of parameters_compiler: ", parameters_compiler::git_commit_hash));
	//wiki.push_back(make_string("// Input file format: ", file_info_.format));
	//wiki.push_back(make_string("// Unit name: ", file_info_.info.get_display_name_cp1251()));
	//wiki.push_back(make_string("// Unit ID: ", file_info_.info.yml.id));
	//wiki.push_back("////////////////////////////////////////////////////////////////////////////////");
	//wiki.push_back("");
	wiki.push_back("== Назначение ==");
	wiki.push_back(make_string(file_info_.info.get_description_wiki(), "<br>"));
	wiki.push_back("");

	for (const auto& ti : file_info_.types)
	{
		std::list<std::string> type_wiki;
		if (!get_type_wiki(ti, type_wiki))
			ELRF("Get type wiki failed");
		for (const auto& s : type_wiki)
			wiki.push_back(s);
		wiki.push_back("");
	}

	std::list<std::string> main_parameters_wiki;
	if (!get_main_wiki(main_parameters_wiki))
		ELRF("Get main parameters wiki failed");
	for (const auto& s : main_parameters_wiki)
		wiki.push_back(s);
	wiki.push_back("");

	wiki.push_back("== Пример конфигурационного файла ==");
	wiki.push_back(make_string("<syntaxhighlight lang=\"xml\">"));
	std::list<std::string> xml;
	if (!get_file_xml(xml))
		ELRF("Get file xml failed");
	for (const auto& s : xml)
		wiki.push_back(s);
	wiki.push_back(make_string("</syntaxhighlight>"));
	wiki.push_back("");

	wiki.push_back("== Версия ==");
	wiki.push_back("@GIT_COMMIT_HASH@<br>");
	wiki.push_back("");

	wiki.push_back("== Автор ==");
	wiki.push_back(file_info_.info.get_author_cp1251());
	wiki.push_back("");

	if (file_info_.info.yml.wiki != "")
	{
		wiki.push_back("== Ссылки ==");
		wiki.push_back(make_string("Описание на wiki: ", file_info_.info.get_wiki_cp1251()));
	}

	return true;
}

bool yaml_parser::get_file_xml(std::list<std::string>& xml)
{
	xml.push_back(make_string("<Unit Name=\"", file_info_.info.yml.hint, "\" Id=\"", file_info_.info.yml.id, "\">"));

	std::list<std::string> parameters_xml;
	if (!get_parameters_xml(file_info_.parameters, parameters_xml))
		ELRF("Get parameters xml failed");
	for (const auto& s : parameters_xml)
		xml.push_back(make_string("\t", s));

	xml.push_back("</Unit>");
	return true;
}

bool yaml_parser::get_file_html(std::list<std::string>& html)
{
	html.push_back("<!DOCTYPE html>");
	html.push_back("<html>");
	html.push_back("<head>");
	html.push_back(make_string("\t<title>", file_info_.info.yml.id, "</title>"));
	html.push_back("\t<link href=\"parameters_compiler.css\" rel=\"stylesheet\" type=\"text/css\">");
	html.push_back("\t<script src=\"highlight.min.js\"></script>");
	html.push_back("\t<script>hljs.initHighlightingOnLoad();</script>");
	html.push_back("</head>");
	html.push_back("");

	html.push_back("<pc-variables>");
	html.push_back(make_string("\t<pc-id>", file_info_.info.yml.id, "</pc-id>"));
	html.push_back(make_string("\t<pc-display-name>", file_info_.info.get_display_name_cp1251(), "</pc-display-name>"));
	html.push_back(make_string("\t<pc-description>", file_info_.info.get_description_html_variables(), "</pc-description>"));
	html.push_back(make_string("\t<pc-category>", file_info_.info.yml.category, "</pc-category>"));
	html.push_back("</pc-variables>");
	html.push_back("");

	html.push_back("<body>");
	html.push_back(make_string("<h1>", file_info_.info.get_display_name_cp1251(), "</h1>"));
	
	// Содержание
	html.push_back("<div class=\"content\">");
	html.push_back("<h2>Содержание</h2>");
	html.push_back("<ol>");
	html.push_back(make_string("<li><a href=\"#purpose\">Назначение</a></li>"));
	for (const auto& ti : file_info_.types)
		html.push_back(make_string("<li><a href=\"#", ti.yml.name, "\">Тип ", ti.yml.name, "</a></li>"));
	if (file_info_.parameters.size() > 0)
		html.push_back(make_string("<li><a href=\"#params\">Параметры юнита</a></li>"));
	html.push_back(make_string("<li><a href=\"#config_xml\">Пример конфигурационного файла</a></li>"));
	html.push_back(make_string("<li><a href=\"#version\">Версия</a></li>"));
	html.push_back(make_string("<li><a href=\"#author\">Автор</a></li>"));
	if (file_info_.info.yml.wiki != "")
		html.push_back(make_string("<li><a href=\"#links\">Ссылки</a></li>"));
	html.push_back("</ol>");
	html.push_back("</div>");

	
	html.push_back(make_string("<a name=\"purpose\"/><h2>Назначение</h2>"));
	html.push_back(make_string("<p>", file_info_.info.get_description_wiki(), "</p>"));
	html.push_back("");

	for (const auto& ti : file_info_.types)
	{
		std::list<std::string> type_html;
		if (!get_type_html(ti, type_html))
			ELRF("Get type html failed");
		for (const auto& s : type_html)
			html.push_back(s);
	}
	html.push_back("");

	std::list<std::string> main_parameters_html;
	if (!get_main_html(main_parameters_html))
		ELRF("Get main parameters html failed");
	for (const auto& s : main_parameters_html)
		html.push_back(s);
	html.push_back("");

	html.push_back("<a name=\"config_xml\"/><h2>Пример конфигурационного файла</h2>");
	html.push_back("<pre><code class=\"xml\">");
	std::list<std::string> xml;
	if (!get_file_xml(xml))
		ELRF("Get file xml failed");
	for (const auto& s : xml)
	{
		std::string ss = s;
		ss = std::regex_replace(ss, std::regex("&"), "&amp;");
		ss = std::regex_replace(ss, std::regex("<"), "&lt;");
		ss = std::regex_replace(ss, std::regex(">"), "&gt;");
		ss = std::regex_replace(ss, std::regex("\""), "&quot;");
		html.push_back(make_string(ss));
	}
	html.push_back("</code></pre>");
	html.push_back("");

	html.push_back("<a name=\"version\"/><h2>Версия</h2>");
	html.push_back("<p>@GIT_COMMIT_HASH@</p>");
	html.push_back("");

	html.push_back("<a name=\"author\"/><h2>Автор</h2>");
	html.push_back(make_string("<p>", file_info_.info.get_author_cp1251(), "</p>"));
	html.push_back("");

	if (file_info_.info.yml.wiki != "")
	{
		html.push_back("<a name=\"links\"/><h2>Ссылки</h2>");
		html.push_back(make_string("<p>Описание на wiki: <a href=\"", file_info_.info.get_wiki_cp1251(), "\">", file_info_.info.get_wiki_cp1251(), "</a></p>"));
	}

	html.push_back("</body>");
	html.push_back("</html>");
	return true;
}

bool yaml_parser::get_type_code(const type_info& ti, std::list<std::string>& code)
{
	if (ti.yml.type == "yml")
	{
		code.push_back(make_string("class ", ti.yml.name));
		code.push_back(make_string("{"));
		code.push_back(make_string("public:"));

		std::list<std::string> struct_members_code;
		if (!get_struct_members_code(ti.parameters, struct_members_code))
			ELRF("Get struct members code failed");
		for (const auto& s : struct_members_code)
			code.push_back(make_string("\t", s));

		code.push_back(make_string(""));
		code.push_back(make_string("\t", "static bool parse(BaseLibrary* base, const std::string& parent_name, ", ti.yml.name, "& value)"));
		code.push_back(make_string("\t", "{"));

		std::list<std::string> parse_members_code;
		if (!get_struct_parse_code(ti.parameters, parse_members_code))
			ELRF("Get parse members code failed");
		for (const auto& s : parse_members_code)
			code.push_back(make_string("\t", s));

		code.push_back(make_string("\t\t", "return true;"));
		code.push_back(make_string("\t", "}"));
		code.push_back(make_string("};"));
	}
	else if (ti.yml.type == "enum")
	{
		code.push_back(make_string("static bool ", ti.get_convert_function_name_text(), "(BaseLibrary* base, const ", ti.type_get, "& xml_value, ", ti.yml.name, "& value)"));
		code.push_back(make_string("{"));

		code.push_back(make_string("\t", "std::map<", ti.type_get, ", ", ti.yml.name, "> enum_values;"));
		for (const auto& v : ti.yml.values)
			code.push_back(make_string("\t", "enum_values[\"", v.first, "\"] = ", v.second, ";"));

		code.push_back(make_string("\t", "if (enum_values.count(xml_value) == 0)"));
		code.push_back(make_string("\t", "{"));
		code.push_back(make_string("\t\t", ERROR_LOG_PREFIX, "\": Значение парамера \" + xml_value + \" отсутствует в перечислении\");"));
		code.push_back(make_string("\t\t", "return false;"));
		code.push_back(make_string("\t", "}"));

		code.push_back(make_string("\t", "value = enum_values[xml_value];"));

		code.push_back(make_string("\t", "return true;"));
		code.push_back(make_string("};"));
	}
	else
		ELRF("Unknown type of type");

	return true;
}

bool yaml_parser::get_type_wiki(const type_info& ti, std::list<std::string>& wiki)
{
	wiki.push_back(make_string("== Тип ", ti.yml.name, " =="));
	if (ti.category == type_category::user_yml)
	{
		wiki.push_back(make_string("{| class=\"wikitable\""));
		wiki.push_back(make_string("|-"));
		wiki.push_back(make_string("! Имя параметра !! Описание !! Обязательный !! Тип !! Тип xml !! Значение по умолчанию !! Типичное значение !! Ограничения"));

		for (const auto& pi : ti.parameters)
		{
			std::list<std::string> parameter_wiki;
			if (!get_parameter_wiki(pi, parameter_wiki))
				ELRF("Get parameter wiki failed");

			for (const auto& s : parameter_wiki)
				wiki.push_back(s);
		}

		wiki.push_back(make_string("|}"));
	}
	else if (ti.category == type_category::user_cpp)
	{
		wiki.push_back(make_string("<p>Данный тип определен в исходных файлах проекта. Значения из конфигурационного файла будут считаны как тип <b><i>",
			ti.type_xml, "</i></b> и приведены к типу <b><i>", ti.yml.name, "</i></b></p>"));
	}

	return true;
}

bool yaml_parser::get_type_html(const type_info& ti, std::list<std::string>& html)
{
	html.push_back(make_string("<a name=\"", ti.yml.name, "\"/>", "<h2>Тип ", ti.yml.name, "</h2>"));
	if (ti.category == type_category::user_yml)
	{
		html.push_back("<table>");
		html.push_back("<tr>");
		html.push_back("<th>Имя параметра</th>");
		html.push_back("<th>Описание</th>");
		html.push_back("<th>Обязательный</th>");
		html.push_back("<th>Тип</th>");
		html.push_back("<th>Тип xml</th>");
		html.push_back("<th>Значение<br/>по умолчанию</th>");
		html.push_back("<th>Типичное<br/>значение</th>");
		html.push_back("<th>Ограничения</th>");
		html.push_back("</tr>");

		for (const auto& pi : ti.parameters)
		{
			std::list<std::string> parameter_html;
			if (!get_parameter_html(pi, parameter_html))
				ELRF("Get parameter html failed");

			for (const auto& s : parameter_html)
				html.push_back(s);
		}

		html.push_back("</table>");
	}
	else if (ti.category == type_category::user_cpp)
	{
		html.push_back(make_string("<p>"));
		html.push_back(make_string(ti.get_description_cp1251(), "<br/>"));
		html.push_back(make_string("Данный тип определен в исходных файлах проекта. Значения из конфигурационного файла будут считаны как тип <b><i>",
			ti.type_xml, "</i></b> и приведены к типу <b><i>", ti.yml.name, "</i></b><br/>"));
		if (ti.yml.type == "enum")
		{
			html.push_back(make_string("Тип использует следующие заголовочные файлы:<br/>"));
			html.push_back(make_string("<ul>"));
			for (const auto& i : ti.yml.includes)
				html.push_back(make_string("<li>", i, "</li>"));
			html.push_back(make_string("</ul>"));

			html.push_back(make_string("В перечислении для использования в xml определены следующие значения:<br/>"));
			html.push_back("<table>");
			html.push_back("<tr>");
			html.push_back("<th>Имя</th>");
			html.push_back("<th>Значение</th>");
			html.push_back("</tr>");
			for (const auto& v : ti.yml.values)
			{
				html.push_back("<tr>");
				html.push_back(make_string("<td>", v.first, "</td>"));
				html.push_back(make_string("<td style=\"text-align:center\">", v.second, "</td>"));
				html.push_back("</tr>");
			}
			html.push_back("</table>");
		}
		html.push_back("</p>");
	}
	return true;
}

bool yaml_parser::get_main_code(std::list<std::string>& code)
{
	code.push_back(make_string("class ", "parameters"));
	code.push_back(make_string("{"));
	code.push_back(make_string("public:"));

	std::list<std::string> struct_members_code;
	if (!get_struct_members_code(file_info_.parameters, struct_members_code))
		ELRF("Get struct members code failed");
	for (const auto& s : struct_members_code)
		code.push_back(make_string("\t", s));

	code.push_back(make_string(""));
	code.push_back(make_string("\t", "static bool parse(BaseLibrary* base, ", "parameters", "& value)"));
	code.push_back(make_string("\t", "{"));
	code.push_back(make_string("\t\t", "std::string parent_name = \"\";"));
	code.push_back(make_string(""));
	code.push_back(make_string("\t\t", INFO_LOG_PREFIX, "\": Хэш коммита: \" + git_commit_hash);"));
	code.push_back(make_string("\t\t", "if (git_status != \"\")"));
	code.push_back(make_string("\t\t\t", INFO_LOG_PREFIX, "\": Статус: \" + git_status);"));
	code.push_back(make_string(""));

	std::list<std::string> parse_members_code;
	if (!get_struct_parse_code(file_info_.parameters, parse_members_code))
		ELRF("Get parse members code failed");
	for (const auto& s : parse_members_code)
		code.push_back(make_string("\t", s));

	code.push_back(make_string("\t\t", "return true;"));
	code.push_back(make_string("\t", "}"));
	code.push_back(make_string("};"));

	return true;
}

bool yaml_parser::get_main_wiki(std::list<std::string>& wiki)
{
	wiki.push_back(make_string("== Параметры юнита =="));
	wiki.push_back(make_string("{| class=\"wikitable\""));
	wiki.push_back(make_string("|-"));
	wiki.push_back(make_string("! Имя параметра !! Описание !! Обязательный !! Тип !! Тип xml !! Значение по умолчанию !! Типичное значение !! Ограничения"));

	for (const auto& pi : file_info_.parameters)
	{
		std::list<std::string> parameter_wiki;
		if (!get_parameter_wiki(pi, parameter_wiki))
			ELRF("Get parameter wiki failed");

		for (const auto& s : parameter_wiki)
			wiki.push_back(s);
	}

	wiki.push_back(make_string("|}"));
	return true;
}

bool yaml_parser::get_main_html(std::list<std::string>& html)
{
	if (file_info_.parameters.size() > 0)
	{
		html.push_back("<a name=\"params\"/><h2>Параметры юнита</h2>");
		html.push_back("<table>");
		html.push_back("<tr>");
		html.push_back("<th>Имя параметра</th>");
		html.push_back("<th>Описание</th>");
		html.push_back("<th>Обязательный</th>");
		html.push_back("<th>Тип</th>");
		html.push_back("<th>Тип xml</th>");
		html.push_back("<th>Значение<br/>по умолчанию</th>");
		html.push_back("<th>Типичное<br/>значение</th>");
		html.push_back("<th>Ограничения</th>");
		html.push_back("</tr>");

		for (const auto& pi : file_info_.parameters)
		{
			std::list<std::string> parameter_html;
			if (!get_parameter_html(pi, parameter_html))
				ELRF("Get parameter html failed");

			for (const auto& s : parameter_html)
				html.push_back(s);
		}

		html.push_back("</table>");
	}
	return true;
}

bool yaml_parser::get_parameters_xml(const std::vector<parameter_info>& parameters, std::list<std::string>& xml)
{
	for (const auto& pi : parameters)
	{
		std::list<std::string> parameter_xml;
		if (!get_parameter_xml(pi, parameter_xml))
			ELRF("Get parameters xml failed");

		for (const auto& s : parameter_xml)
			xml.push_back(s);
	}
	return true;
}

bool yaml_parser::get_struct_members_code(const std::vector<parameter_info>& parameters, std::list<std::string>& code)
{
	for (const auto& pi : parameters)
	{
		code.push_back(make_string(pi.type_class, " ", pi.get_name_text(), ";"));
		if (pi.is_optional)
			code.push_back(make_string("bool ", pi.get_optional_name_text(), ";"));
	}
	return true;
}

bool yaml_parser::get_struct_parse_code(const std::vector<parameter_info>& parameters, std::list<std::string>& code)
{
	for (const auto& pi : parameters)
	{
		std::list<std::string> parameter_code;
		if (!get_parameter_code(pi, parameter_code))
			ELRF("Get parameter code failed");
		for (const auto& s : parameter_code)
			code.push_back(s);
	}
	return true;
}

bool yaml_parser::get_parameter_code(const parameter_info& pi, std::list<std::string>& code)
{
	if (pi.is_array)
	{
		code.push_back(make_string("\t", "std::string ", pi.get_name_name_text(), " = parent_name + \"", pi.yml.name, "\";"));
		code.push_back(make_string("\t", "std::string ", pi.get_count_name_name_text(), " = parent_name + \"", pi.get_count_xml_name_text(), "\";"));
		code.push_back(make_string("\t", "int ", pi.get_count_value_name_text(), " = 0;"));
		code.push_back(make_string("\t", "if (!base->GetParameter(", pi.get_count_name_name_text(), ", ", pi.get_count_value_name_text(), "))"));
		code.push_back(make_string("\t\t", pi.get_count_value_name_text(), " = 0;"));

		std::list<std::string> restrictions_code;
		get_restrictions_code(pi, true, restrictions_code);
		for (const auto& s : restrictions_code)
			code.push_back(make_string("\t", s));

		code.push_back(make_string(""));
		code.push_back(make_string("\t", "for (int i = 0; i < ", pi.get_count_value_name_text(), "; i++)"));
		code.push_back(make_string("\t", "{"));
		if (pi.category == type_category::user_yml)
		{
			code.push_back(make_string("\t\t", "std::string ", pi.get_name_name_text(), " = parent_name + \"", pi.yml.name, "\"", " + ", "\"__\" + ", "std::to_string(i) + \"__\";"));
			code.push_back(make_string("\t\t", pi.item_type_class, " ", pi.get_value_name_text(), "{};"));
			code.push_back(make_string("\t\t", "if (!", pi.item_type_class, "::parse(base, ", pi.get_name_name_text(), ", ", pi.get_value_name_text(), "))"));
			code.push_back(make_string("\t\t", "{"));
			code.push_back(make_string("\t\t\t", ERROR_LOG_PREFIX, "\": Неверный формат параметра \" + ", pi.get_name_name_text(), " + \"\");"));
			code.push_back(make_string("\t\t\t", "return false;"));
			code.push_back(make_string("\t\t", "}"));
			code.push_back(make_string("\t\t", "value.", pi.get_name_text(), ".push_back(", pi.get_value_name_text(), ");"));

			// Пользовательские типы имеют свою функцию парсинга, поэтому выводят сообщения в ней
			// Все значения должны быть успешно считаны, либо выходим с ошибкой
		}
		else
		{
			code.push_back(make_string("\t\t", "std::string ", pi.get_name_name_text(), " = parent_name + \"", pi.yml.name, "\"", " + ", "\"__\" + ", "std::to_string(i);"));
			code.push_back(make_string("\t\t", pi.item_type_get, " ", pi.get_value_name_text(), "{};"));
			code.push_back(make_string("\t\t", "if (!base->GetParameter(", pi.get_name_name_text(), ", ", pi.get_value_name_text(), "))"));
			code.push_back(make_string("\t\t", "{"));
			code.push_back(make_string("\t\t\t", ERROR_LOG_PREFIX, "\": Параметр не прочитан \" + ", pi.get_name_name_text(), " + \"\");"));
			code.push_back(make_string("\t\t\t", "return false;"));
			code.push_back(make_string("\t\t", "}"));
			code.push_back("");

			std::list<std::string> restrictions_code;
			get_restrictions_code(pi, false, restrictions_code);
			for (const auto& s : restrictions_code)
				code.push_back(make_string("\t\t", s));
			code.push_back("");

			// В типизированных массивах стандартных типов не может быть параметров по умолчанию,
			// поэтому все значения должны быть успешно считаны, либо выходим с ошибкой

			// Выводим в лог значение параметра
			// Параметры выводим не преобразуя тип к пользовательскому, так как не все они могут быть преобразованы в строку
			// Выводим через std::to_string() тип parameter_xml_type, кроме строк, которые выводятся как есть
			if (pi.item_type_get == "std::string")
			{
				code.push_back(make_string("\t\t", "if (", pi.get_value_name_text(), " == \"\")"));
				code.push_back(make_string("\t\t\t", INFO_LOG_PREFIX, "\": Задан параметр \" + ", pi.get_name_name_text(), " + \": \\\"\\\"\"", ");"));
				code.push_back(make_string("\t\t", "else"));
				code.push_back(make_string("\t\t\t", INFO_LOG_PREFIX, "\": Задан параметр \" + ", pi.get_name_name_text(), " + \": \" + ", pi.get_value_name_text(), ");"));
			}
			else
				code.push_back(make_string("\t\t", INFO_LOG_PREFIX, "\": Задан параметр \" + ", pi.get_name_name_text(), " + \": \" + std::to_string(", pi.get_value_name_text(), "));"));

			code.push_back(make_string(""));
			// Заполнем структуру, если тип отличается, преобразуем
			if (pi.category == type_category::user_cpp)
			{
				type_info ti;
				if (!file_info_.get_type(pi.item_type, ti))
					ELRF("Unknown cpp type" << pi.item_type);

				code.push_back(make_string("\t\t", "{"));
				code.push_back(make_string("\t\t\t", pi.item_type, " temp_value{};"));
				code.push_back(make_string("\t\t\t", "if (!", ti.get_convert_function_name_text(), "(base, ", pi.get_value_name_text(), ", temp_value))"));
				code.push_back(make_string("\t\t\t", "{"));
				code.push_back(make_string("\t\t\t\t", ERROR_LOG_PREFIX, "\": Параметр не конвертирован \" + ", pi.get_name_name_text(), ");"));
				code.push_back(make_string("\t\t\t\t", "return false;"));
				code.push_back(make_string("\t\t\t", "}"));
				code.push_back(make_string("\t\t\t", "value.", pi.get_name_text(), ".push_back(temp_value);"));
				code.push_back(make_string("\t\t", "}"));
			}
			else if (pi.item_type_class != pi.item_type_get)
				code.push_back(make_string("\t\t", "value.", pi.get_name_text(), ".push_back(static_cast<", pi.item_type_class, ">(", pi.get_value_name_text(), "));"));
			else
				code.push_back(make_string("\t\t", "value.", pi.get_name_text(), ".push_back(", pi.get_value_name_text(), ");"));

		}
		code.push_back(make_string("\t", "}"));
		code.push_back(make_string(""));
	}
	else
	{
		code.push_back(make_string("\t", "std::string ", pi.get_name_name_text(), " = parent_name + \"", pi.yml.name, "\";"));
		code.push_back(make_string("\t", pi.item_type_get, " ", pi.get_value_name_text(), "{};"));
		code.push_back(make_string("\t", "if (!base->GetParameter(", pi.get_name_name_text(), ", ", pi.get_value_name_text(), "))"));

		if (pi.is_required)
		{
			code.push_back(make_string("\t", "{"));
			code.push_back(make_string("\t\t", ERROR_LOG_PREFIX, "\": Не задан обязательный параметр \" + ", pi.get_name_name_text(), " + \"\");"));
			code.push_back(make_string("\t\t", "return false;"));
			code.push_back(make_string("\t", "}"));
		}
		else
		{
			code.push_back(make_string("\t", "{"));
			if (pi.is_optional)
			{
				code.push_back(make_string("\t\t", INFO_LOG_PREFIX, "\": Не задан опциональный параметр \" + ", pi.get_name_name_text(), " + \". Установлено значение ", pi.get_optional_name_text(), ": false\");"));
				code.push_back(make_string("\t\t", "value.", pi.get_optional_name_text(), " = false;"));
			}
			else
			{
				code.push_back(make_string("\t\t", INFO_LOG_PREFIX, "\": Не задан параметр \" + ", pi.get_name_name_text(), " + \". Установлено значение по-умолчанию: ", pi.yml.default_ == "" ? "\\\"\\\"" : pi.get_default_cp1251(), "\");"));
				if (pi.item_type_get == "std::string")
					code.push_back(make_string("\t\t", pi.get_value_name_text(), " = \"", pi.get_default_cp1251(), "\"; "));
				else if (pi.item_type_class != pi.item_type_get)
					code.push_back(make_string("\t\t", pi.get_value_name_text(), " = static_cast<", pi.item_type_get, ">(", pi.yml.default_, ");"));
				else
					code.push_back(make_string("\t\t", pi.get_value_name_text(), " = ", pi.get_default_cp1251(), "; "));
			}
			code.push_back(make_string("\t", "}"));
		}


		// Выводим в лог значение параметра, если оно считано успешно
		// Параметры выводим не преобразуя тип к пользовательскому, так как не все они могут быть преобразованы в строку
		// Выводим через std::to_string() тип parameter_xml_type, кроме строк, которые выводятся как есть
		code.push_back(make_string("\t", "else"));
		code.push_back(make_string("\t", "{"));

		std::list<std::string> restrictions_code;
		get_restrictions_code(pi, false,  restrictions_code);
		for (const auto& s : restrictions_code)
			code.push_back(make_string("\t\t", s));
		code.push_back("");

		if (pi.is_optional)
		{
			code.push_back(make_string("\t\t", INFO_LOG_PREFIX, "\": Задан опциональный параметр \" + ", pi.get_name_name_text(), " + \". Установлено значение ", pi.get_optional_name_text(), ": true\");"));
			code.push_back(make_string("\t\t", "value.", pi.get_optional_name_text(), " = true;"));
		}
		if (pi.item_type_get == "std::string")
		{
			code.push_back(make_string("\t\t", "if (", pi.get_value_name_text(), " == \"\")"));
			code.push_back(make_string("\t\t\t", INFO_LOG_PREFIX, "\": Задан параметр \" + ", pi.get_name_name_text(), " + \": \\\"\\\"\"", ");"));
			code.push_back(make_string("\t\t", "else"));
			code.push_back(make_string("\t\t\t", INFO_LOG_PREFIX, "\": Задан параметр \" + ", pi.get_name_name_text(), " + \": \" + ", pi.get_value_name_text(), ");"));
		}
		else
			code.push_back(make_string("\t\t", INFO_LOG_PREFIX, "\": Задан параметр \" + ", pi.get_name_name_text(), " + \": \" + std::to_string(", pi.get_value_name_text(), "));"));
		code.push_back(make_string("\t", "}"));

		// Заполнем структуру, если тип отличается, преобразуем
		if (pi.category == type_category::user_cpp)
		{
			type_info ti;
			if (!file_info_.get_type(pi.item_type, ti))
				ELRF("Unknown cpp type" << pi.item_type);

			code.push_back(make_string("\t", "{"));
			code.push_back(make_string("\t\t", pi.item_type, " temp_value{};"));
			code.push_back(make_string("\t\t", "if (!", ti.get_convert_function_name_text(), "(base, ", pi.get_value_name_text(), ", temp_value))"));
			code.push_back(make_string("\t\t", "{"));
			code.push_back(make_string("\t\t\t", ERROR_LOG_PREFIX, "\": Параметр не конвертирован \" + ", pi.get_name_name_text(), ");"));
			code.push_back(make_string("\t\t\t", "return false;"));
			code.push_back(make_string("\t\t", "}"));
			code.push_back(make_string("\t\t", "value.", pi.get_name_text(), " = temp_value;"));
			code.push_back(make_string("\t", "}"));
		}
		else if (pi.item_type_class != pi.item_type_get)
			code.push_back(make_string("\t", "value.", pi.get_name_text(), " = static_cast<", pi.item_type_class, ">(", pi.get_value_name_text(), ");"));
		else
			code.push_back(make_string("\t", "value.", pi.get_name_text(), " = ", pi.get_value_name_text(), ";"));
		code.push_back(make_string(""));
	}
	return true;
}

bool yaml_parser::get_parameter_wiki(const parameter_info& pi, std::list<std::string>& wiki)
{
	std::string restrictions_wiki;
	if (!get_restrictions_wiki(pi, restrictions_wiki))
		ELRF("Get restrictions failed");

	wiki.push_back(make_string("|-"));
	wiki.push_back(make_string("| ", pi.yml.name, " || ", pi.get_description_wiki(), " || ", pi.get_is_required_wiki(),
		" || ", pi.get_type_wiki(), " || ", pi.get_type_xml_wiki(), " || ", pi.get_default_wiki(), " || ", pi.get_hint_cp1251(), " || ", restrictions_wiki));

	return true;
}

bool yaml_parser::get_parameter_xml(const parameter_info& pi, std::list<std::string>& xml)
{
	if (pi.is_array)
	{
		int count = pi.get_restricted_count_xml();

		if (pi.category == type_category::user_yml)
		{
			// Это вложенный тип данных, вызываем get_parameters_xml реккурсивно
			xml.push_back(make_string("<Array name=\"", pi.yml.name, "\">"));

			type_info ti{};
			if (!file_info_.get_type(pi.item_type, ti))
				ELRF("Get type failed, name = " << pi.item_type);

			std::list<std::string> parameters_xml;
			if (!get_parameters_xml(ti.parameters, parameters_xml))
				ELRF("Get parameters xml failed");

			for (int i = 0; i < count; i++)
			{
				xml.push_back("\t<Item>");
				for (const auto& s : parameters_xml)
					xml.push_back(make_string("\t\t", s));
				xml.push_back("\t</Item>");
			}

			xml.push_back("</Array>");
		}
		else
		{
			// Это типизированный массив. Тип данных может быть стандартными или пользовательским типа cpp
			xml.push_back(make_string("<Array name=\"", pi.yml.name, "\" type=\"", pi.item_type_xml, "\">"));

			for (int i = 0; i < count; i++)
				xml.push_back(make_string("\t<Item val=\"", pi.get_restricted_value_xml(), "\"/>"));

			xml.push_back("</Array>");
		}
	}
	else
	{
		if (pi.item_type == "unit")
			xml.push_back(make_string("<Param name=\"", pi.yml.name, "\" type=\"", pi.item_type_xml, "\" val=\"", pi.get_restricted_value_xml(), "\" depends=\"true\"/>"));
		else
			xml.push_back(make_string("<Param name=\"", pi.yml.name, "\" type=\"", pi.item_type_xml, "\" val=\"", pi.get_restricted_value_xml(), "\"/>"));
	}

	return true;
}

bool yaml_parser::get_parameter_html(const parameter_info& pi, std::list<std::string>& html)
{
	std::string restrictions_html;
	if (!get_restrictions_html(pi, restrictions_html))
		ELRF("Get restrictions failed");

	html.push_back("<tr>");
	html.push_back(make_string("<td>", pi.yml.name, "</td>"));
	html.push_back(make_string("<td>", pi.get_description_cp1251(), "</td>"));
	html.push_back(make_string("<td style=\"text-align:center\">", pi.get_is_required_cp1251(), "</td>"));
	html.push_back(make_string("<td style=\"text-align:center\">", pi.get_type_html(), "</td>"));
	html.push_back(make_string("<td style=\"text-align:center\">", pi.get_type_xml_html(), "</td>"));
	html.push_back(make_string("<td style=\"text-align:center\">", pi.get_default_cp1251(), "</td>"));
	html.push_back(make_string("<td style=\"text-align:center\">", pi.get_hint_cp1251(), "</td>"));
	html.push_back(make_string("<td>", restrictions_html, "</td>"));
	html.push_back("</tr>");
	return true;
}

bool yaml_parser::get_restrictions_code(const parameter_info& pi, const bool for_array, std::list<std::string>& code)
{
	if (pi.has_restrictions)
	{
		bool first_string = true;
		if (for_array && pi.is_array)
		{
			if (pi.is_required)
			{
				if (first_string) first_string = false; else code.push_back(make_string(""));
				code.push_back(make_string("", "if (", pi.get_count_value_name_text(), " == 0)"));
				code.push_back(make_string("", "{"));
				code.push_back(make_string("\t", ERROR_LOG_PREFIX, "\": Обязательный параметр \" + ", pi.get_name_name_text(), " + \" пуст\");"));
				code.push_back(make_string("\t", "return false;"));
				code.push_back(make_string("", "}"));
			}

			if (pi.yml.restrictions.min_count != "")
			{
				if (first_string) first_string = false; else code.push_back(make_string(""));
				code.push_back(make_string("", "if (", pi.get_count_value_name_text(), " < ", pi.yml.restrictions.min_count, ")"));
				code.push_back(make_string("", "{"));
				code.push_back(make_string("\t", ERROR_LOG_PREFIX, "\": Количество парамеров \" + ", pi.get_name_name_text(), " + \" меньше допустимого\");"));
				code.push_back(make_string("\t", "return false;"));
				code.push_back(make_string("", "}"));
			}

			if (pi.yml.restrictions.max_count != "")
			{
				if (first_string) first_string = false; else code.push_back(make_string(""));
				code.push_back(make_string("", "if (", pi.get_count_value_name_text(), " > ", pi.yml.restrictions.max_count, ")"));
				code.push_back(make_string("", "{"));
				code.push_back(make_string("\t", ERROR_LOG_PREFIX, "\": Количество парамеров \" + ", pi.get_name_name_text(), " + \" больше допустимого\");"));
				code.push_back(make_string("\t", "return false;"));
				code.push_back(make_string("", "}"));
			}

			if (pi.yml.restrictions.set_count.size() > 0)
			{
				if (first_string) first_string = false; else code.push_back(make_string(""));
				code.push_back(make_string("", "std::set<int> ", pi.get_count_value_set_name_text(), ";"));
				for (const auto& v : pi.yml.restrictions.set_count)
					code.push_back(make_string("", pi.get_count_value_set_name_text(), ".insert(", v, ");"));
				code.push_back(make_string("", "if (", pi.get_count_value_set_name_text(), ".count(", pi.get_count_value_name_text(), ") == 0)"));
				code.push_back(make_string("", "{"));
				code.push_back(make_string("\t", ERROR_LOG_PREFIX, "\": Количество парамеров \" + ", pi.get_name_name_text(), " + \" отсутствует в списке допустимых\");"));
				code.push_back(make_string("\t", "return false;"));
				code.push_back(make_string("", "}"));
			}
		}
		else
		{
			if (pi.yml.restrictions.min != "")
			{
				if (first_string) first_string = false; else code.push_back(make_string(""));
				code.push_back(make_string("", "if (", pi.get_value_name_text(), " < ", pi.yml.restrictions.min, ")"));
				code.push_back(make_string("", "{"));
				code.push_back(make_string("\t", ERROR_LOG_PREFIX, "\": Значение парамера \" + ", pi.get_name_name_text(), " + \" меньше допустимого\");"));
				code.push_back(make_string("\t", "return false;"));
				code.push_back(make_string("", "}"));
			}

			if (pi.yml.restrictions.max != "")
			{
				if (first_string) first_string = false; else code.push_back(make_string(""));
				code.push_back(make_string("", "if (", pi.get_value_name_text(), " > ", pi.yml.restrictions.max, ")"));
				code.push_back(make_string("", "{"));
				code.push_back(make_string("\t", ERROR_LOG_PREFIX, "\": Значение парамера \" + ", pi.get_name_name_text(), " + \" больше допустимого\");"));
				code.push_back(make_string("\t", "return false;"));
				code.push_back(make_string("", "}"));
			}

			if (pi.yml.restrictions.set_.size() > 0)
			{
				if (first_string) first_string = false; else code.push_back(make_string(""));
				code.push_back(make_string("", "std::set<", pi.item_type_get, "> ", pi.get_value_set_name_text(), ";"));
				for (const auto& v : pi.get_restrictions_set_cp1251())
				{
					if (pi.item_type_get == "std::string")
						code.push_back(make_string("", pi.get_value_set_name_text(), ".insert(\"", v, "\");"));
					else
						code.push_back(make_string("", pi.get_value_set_name_text(), ".insert(static_cast<", pi.item_type_get, ">(", v, "));"));
				}
				code.push_back(make_string("", "if (", pi.get_value_set_name_text(), ".count(", pi.get_value_name_text(), ") == 0)"));
				code.push_back(make_string("", "{"));
				code.push_back(make_string("\t", ERROR_LOG_PREFIX, "\": Значение парамера \" + ", pi.get_name_name_text(), " + \" отсутствует в списке допустимых\");"));
				code.push_back(make_string("\t", "return false;"));
				code.push_back(make_string("", "}"));
			}
		}
	}
	return true;
}

bool yaml_parser::get_restrictions_wiki(const parameter_info& pi, std::string& wiki)
{
	if (pi.has_restrictions)
	{
		if (pi.is_array)
		{
			if (pi.yml.restrictions.min_count != "")
				wiki += make_string("Минимальное количество элементов: ", pi.yml.restrictions.min_count, "<br>");
			if (pi.yml.restrictions.max_count != "")
				wiki += make_string("Максимальное количество элементов: ", pi.yml.restrictions.max_count, "<br>");
			if (pi.yml.restrictions.set_count.size() > 0)
			{
				wiki += make_string("Допустимое количество элементов: ");
				for (int i = 0; i < pi.yml.restrictions.set_count.size(); i++)
				{
					std::string value_str = make_string(pi.yml.restrictions.set_count[i]);
					if (value_str.length() > 10)
						wiki += "<br>";
					wiki += value_str;
					if (i < pi.yml.restrictions.set_count.size() - 1)
						wiki += ", ";
				}
				wiki += "<br>";
			}
		}
		else
		{
			if (pi.yml.restrictions.min != "")
				wiki += make_string("Минимальное значение: ", pi.yml.restrictions.min, "<br>");
			if (pi.yml.restrictions.max != "")
				wiki += make_string("Максимальное значение: ", pi.yml.restrictions.max, "<br>");
			if (pi.yml.restrictions.set_.size() > 0)
			{
				wiki += "Допустимые значения: ";
				const auto set_cp1251 = pi.get_restrictions_set_cp1251();
				for (int i = 0; i < set_cp1251.size(); i++)
				{
					std::string value_str = set_cp1251[i];
					if (value_str.length() > 10)
						wiki += "<br>";
					wiki += value_str;
					if (i < set_cp1251.size() - 1)
						wiki += ", ";
				}
				wiki += "<br>";
			}

			if (pi.type == "path" && pi.yml.restrictions.max_length != "")
				wiki += make_string("Максимальная длина: ", pi.yml.restrictions.max_length, "<br>");

			if (pi.type == "unit" && pi.yml.restrictions.category != "")
				wiki += make_string("Допустимые категории: ", pi.yml.restrictions.category, "<br>");

			if (pi.type == "unit" && pi.yml.restrictions.ids.size() > 0)
			{
				wiki += "Допустимые юниты: ";
				for (int i = 0; i < pi.yml.restrictions.ids.size(); i++)
				{
					std::string value_str = pi.yml.restrictions.ids[i];
					if (value_str.length() > 10)
						wiki += "<br>";
					wiki += value_str;
					if (i < pi.yml.restrictions.ids.size() - 1)
						wiki += ", ";
				}
				wiki += "<br>";
			}
		}
	}
	return true;
}

bool yaml_parser::get_restrictions_html(const parameter_info& pi, std::string& html)
{
	return get_restrictions_wiki(pi, html);
}

bool yaml_parser::get_file_info(const YAML::Node& node, file_info& fi)
{
	// Optional members from yml
	if (!try_get_yaml_value<std::string>(node, "FILE_FORMAT", fi.yml.format))
		fi.yml.format = "1";

	// Evaluated members
	fi.format = atoi(fi.yml.format.c_str());

	YAML::Node info = node["INFO"];
	if (!info)
		ELRF("Get INFO node failed");

	if (!get_info_info(info, fi.info))
		ELRF("Unit info parse failed");

	YAML::Node types = node["TYPES"];
	for (const auto& type : types)
	{
		type_info ti{};
		if (!get_type_info(type, fi.types, ti))
			ELRF("Type info parse failed");
		fi.types.push_back(std::move(ti));
	}

	YAML::Node parameters = node["PARAMETERS"];
	for (const auto& parameter : parameters)
	{
		parameter_info pi{};
		if (!get_parameter_info(parameter, fi.types, pi))
			ELRF("Parameter info parse failed");
		fi.parameters.push_back(std::move(pi));
	}

	return true;
}

bool yaml_parser::get_info_info(const YAML::Node& node, info_info& ui)
{
	// Required members from yml
	if (!try_get_yaml_value<std::string>(node, "ID", ui.yml.id))
		ELRF("Get unit ID node failed");

	// Optional members from yml
	if (!try_get_yaml_value<std::string>(node, "DISPLAY_NAME", ui.yml.display_name))
		ui.yml.display_name = ui.yml.id;
	if (!try_get_yaml_value<std::string>(node, "DESCRIPTION", ui.yml.description))
		ui.yml.description = ui.yml.display_name;
	if (!try_get_yaml_value<std::string>(node, "CATEGORY", ui.yml.category))
		ui.yml.category = "No category";
	if (!try_get_yaml_value<std::string>(node, "HINT", ui.yml.hint))
		ui.yml.hint = ui.yml.id;
	if (!try_get_yaml_value<std::string>(node, "PICTOGRAM", ui.yml.pictogram))
		ui.yml.pictogram = "";
	if (!try_get_yaml_value<std::string>(node, "AUTHOR", ui.yml.author))
		ui.yml.author = "Noname";
	if (!try_get_yaml_value<std::string>(node, "WIKI", ui.yml.wiki))
		ui.yml.wiki = "";

	return true;
}

bool yaml_parser::get_type_info(const YAML::Node& node, const std::vector<type_info>& type_infos, type_info& ti)
{
	// Required members from yml
	if (!try_get_yaml_value<std::string>(node, "NAME", ti.yml.name))
		ELRF("Get parameter NAME node failed");

	// Optional members from yml
	if (!try_get_yaml_value<std::string>(node, "TYPE", ti.yml.type))
		ti.yml.type = "yml";
	if (!try_get_yaml_value<std::string>(node, "DESCRIPTION", ti.yml.description))
		ti.yml.description = ti.yml.name;

	// Evaluated members
	ti.category = ti.yml.type == "yml" ? type_category::user_yml : type_category::user_cpp;

	if (ti.yml.type == "yml")
	{
		YAML::Node parameters = node["PARAMETERS"];
		for (const auto& parameter : parameters)
		{
			parameter_info pi;
			if (!get_parameter_info(parameter, type_infos, pi))
				ELRF("Get parameter info failed");
			ti.parameters.push_back(std::move(pi));
		}
	}
	else if (ti.yml.type == "enum")
	{
		YAML::Node values = node["VALUES"];
		for (const auto& value : values)
			ti.yml.values[value.first.as<std::string>()] = value.second.as<std::string>();

		YAML::Node includes = node["INCLUDES"];
		for (const auto& include : includes)
			ti.yml.includes.push_back(include.as<std::string>());

		// Type ti.yml.type == "enum" always exists
		ti.type_xml = type_type_names_[ti.yml.type];

		const auto xml_type = xml_type_names_.find(ti.type_xml);
		if (xml_type != xml_type_names_.cend())
			ti.type_get = xml_type->second;
		else
			ELRF("Unknown xml type");
	}
	else
		ELRF("Unknown type of type");
	return true;
}

bool yaml_parser::get_parameter_info(const YAML::Node& node, const std::vector<type_info>& type_infos, parameter_info& pi)
{
	// Get required members
	if (!try_get_yaml_value<std::string>(node, "TYPE", pi.yml.type))
		ELRF("Get parameter TYPE node failed");
	if (!try_get_yaml_value<std::string>(node, "NAME", pi.yml.name))
		ELRF("Get parameter NAME node failed");

	// Get optional members
	bool parameter_has_default = true;
	if (!try_get_yaml_value<std::string>(node, "DEFAULT", pi.yml.default_))
	{
		parameter_has_default = false;
		pi.yml.default_ = "";
	}
	if (!try_get_yaml_value<std::string>(node, "DISPLAY_NAME", pi.yml.display_name))
		pi.yml.display_name = pi.yml.name;
	if (!try_get_yaml_value<std::string>(node, "DESCRIPTION", pi.yml.description))
		pi.yml.description = pi.yml.display_name;
	if (!try_get_yaml_value<std::string>(node, "HINT", pi.yml.hint))
		pi.yml.hint = "";

	// Evaluated members
	pi.type = pi.yml.type;

	if (pi.type.length() > std::string("array<>").length() &&
		pi.type.substr(0, std::string("array<").length()) == "array<" &&
		pi.type[pi.type.length() - 1] == '>')
	{
		pi.is_array = true;
		pi.item_type = pi.type.substr(std::string("array<").length(), pi.type.length() - std::string("array<>").length());
	}
	else
	{
		pi.is_array = false;
		pi.item_type = pi.type;
	}

	{
		const auto system_type = system_type_names_.find(pi.item_type);
		if (system_type != system_type_names_.cend())
		{
			// Если тип системный, берем из карты system_type_names_ имя параметра для xml
			pi.item_type_xml = system_type->second;
			pi.category = type_category::system;
		}
		else
		{
			const auto cpp_type = cpp_type_names_.find(pi.item_type);
			if (cpp_type != cpp_type_names_.cend())
			{
				// Если тип стандартный, берем из карты cpp_type_names_ имя параметра для xml
				pi.item_type_xml = cpp_type->second;
				pi.category = type_category::cpp;
			}
			else
			{
				// Если тип пользовательский, то он должен быть в user_type_infos_
				const auto user_type = std::find_if(type_infos.cbegin(), type_infos.cend(), [pi](const type_info& ti) {return pi.item_type == ti.yml.name; });
				if (user_type != type_infos.cend())
				{
					// Если тип - это описание параметров, то это yml тип, берем его имя
					// Если тип это псевдоним для типа из исходников - это тип cpp, для него должен быть задан TYPE_XML
					if (user_type->is_user_cpp())
					{
						pi.item_type_xml = user_type->type_xml;
						pi.category = type_category::user_cpp;
					}
					else
					{
						pi.item_type_xml = user_type->yml.name;
						pi.category = type_category::user_yml;
					}
				}
				else
					ELRF("Unknown parameter type (item_type_xml)");
			}
		}
	}

	{
		const auto system_type = system_type_names_.find(pi.item_type);
		if (system_type != system_type_names_.cend())
		{
			// Если тип системный, берем из карты xml_type_names_ по имени параметра для xml
			// т.к. системные типы (unit, path) не известны в cpp и должны замениться на cpp-шные
			pi.item_type_class = xml_type_names_[system_type->second];
		}
		else
		{
			const auto cpp_type = cpp_type_names_.find(pi.item_type);
			if (cpp_type != cpp_type_names_.cend())
			{
				// Если тип стандартный, берем его как есть
				pi.item_type_class = pi.item_type;
			}
			else
			{
				// Если тип пользовательский, то он должен быть в user_type_infos_
				const auto user_type = std::find_if(type_infos.cbegin(), type_infos.cend(), [pi](const type_info& ti) {return pi.item_type == ti.yml.name; });
				if (user_type != type_infos.cend())
				{
					// Если это yml тип, то параметр имеет смысл только для массивов, т.к. в обычных параметрах yml типы не применимы
					// Если это тип cpp, то параметр может применяться без массива
					pi.item_type_class = user_type->yml.name;
				}
				else
					ELRF("Unknown parameter type (item_type_class)");
			}
		}
	}

	const auto xml_type = xml_type_names_.find(pi.item_type_xml);
	if (xml_type != xml_type_names_.cend())
	{
		// Если это не пользовательский yml тип, берем из карты xml_type_names_ по имени параметра для xml
		pi.item_type_get = xml_type->second;
	}
	else
		pi.item_type_get = "";

	if (pi.is_array)
	{
		pi.type_xml = std::string("array<") + pi.item_type_xml + ">";
		pi.type_class = std::string("std::vector<") + pi.item_type_class + ">";
	}
	else
	{
		pi.type_xml = pi.item_type_xml;
		pi.type_class = pi.item_type_class;
	}

	if (!try_get_yaml_value<bool>(node, "REQUIRED", pi.is_required))
		pi.is_required = true;

	if (pi.is_required)
	{
		pi.is_optional = false;
	}
	else
	{
		if (parameter_has_default)
		{
			if (pi.item_type_get != "std::string" && pi.yml.default_ == "")
				ELRF("Default value is empty");
			pi.is_optional = false;
		}
		else
		{
			pi.is_optional = true;
		}
	}

	YAML::Node restrictions = node["RESTRICTIONS"];
	if (restrictions)
	{
		pi.has_restrictions = true;
		if (!try_get_yaml_value<std::string>(restrictions, "MIN", pi.yml.restrictions.min))
			pi.yml.restrictions.min = "";
		if (!try_get_yaml_value<std::string>(restrictions, "MAX", pi.yml.restrictions.max))
			pi.yml.restrictions.max = "";
		YAML::Node required_set = restrictions["SET"];
		for (const auto& v : required_set)
			pi.yml.restrictions.set_.push_back(v.as<std::string>());
		if (!try_get_yaml_value<std::string>(restrictions, "MIN_COUNT", pi.yml.restrictions.min_count))
			pi.yml.restrictions.min_count = "";
		if (!try_get_yaml_value<std::string>(restrictions, "MAX_COUNT", pi.yml.restrictions.max_count))
			pi.yml.restrictions.max_count = "";
		YAML::Node required_set_count = restrictions["SET_COUNT"];
		for (const auto& v : required_set_count)
			pi.yml.restrictions.set_count.push_back(v.as<std::string>());
		if (!try_get_yaml_value<std::string>(restrictions, "CATEGORY", pi.yml.restrictions.category))
			pi.yml.restrictions.category = "";
		YAML::Node required_ids = restrictions["IDS"];
		for (const auto& v : required_ids)
			pi.yml.restrictions.ids.push_back(v.as<std::string>());
		if (!try_get_yaml_value<std::string>(restrictions, "MAX_LENGTH", pi.yml.restrictions.max_length))
			pi.yml.restrictions.max_length = "";
	}
	else
		pi.has_restrictions = false;

	return true;
}
